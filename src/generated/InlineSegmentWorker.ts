// File generated at build time (plugins/SetupInlineWorker.ts)
const workerScript = "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nif (false) {\n    var parentPort_1 = require(\"worker_threads\").parentPort;\n    parentPort_1 === null || parentPort_1 === void 0 ? void 0 : parentPort_1.on(\"message\", function (message) {\n        var response = handleMessage(message);\n        parentPort_1 === null || parentPort_1 === void 0 ? void 0 : parentPort_1.postMessage(response);\n    });\n}\nelse {\n    self.addEventListener(\"message\", function (event) {\n        var response = handleMessage(event.data);\n        self.postMessage(response);\n    });\n}\nvar handleMessage = function (event) {\n    var type = event.type, payload = event.payload, taskId = event.taskId;\n    if (type === \"SOLVE\") {\n        var result = resolveSequence(payload);\n        var response = {\n            type: \"RESULT\",\n            payload: result,\n            taskId: taskId,\n        };\n        return response;\n    }\n};\n// Cache for memoization using closure\nvar memoCache = new Map();\nvar getCacheKey = function (hints, segment, startIndex) {\n    return \"\".concat(hints.join(\",\"), \"-\").concat(segment.join(\",\"), \"-\").concat(startIndex);\n};\nvar resolveSequence = function (_a) {\n    var hints = _a.hints, segment = _a.segment;\n    // Quick validation\n    var totalFilled = hints.reduce(function (sum, hint) { return sum + hint; }, 0);\n    var minSpace = getMinSpaceNeeded(hints);\n    var existingFilled = segment.filter(function (cell) { return cell === 2; }).length;\n    if (minSpace > segment.length || existingFilled > totalFilled) {\n        throw new Error(\"Segment not possible to solve\");\n    }\n    // Clear memoization cache for new sequence\n    memoCache.clear();\n    // Validate if the sequence is possible\n    if (!canPlaceHints(hints, segment, 0)) {\n        throw new Error(\"Segment not possible to solve\");\n    }\n    // Initialize result array\n    var result = __spreadArray([], segment, true);\n    // For each unknown cell, check if it must be filled or empty\n    for (var i = 0; i < segment.length; i++) {\n        if (segment[i] !== 0)\n            continue; // Skip known cells\n        var mustBeFilled = checkMustBe(hints, segment, i, 2);\n        var mustBeEmpty = checkMustBe(hints, segment, i, 1);\n        if (mustBeFilled && !mustBeEmpty) {\n            result[i] = 2;\n        }\n        else if (!mustBeFilled && mustBeEmpty) {\n            result[i] = 1;\n        }\n        // If both are possible, leave as unknown (0)\n    }\n    return result;\n};\nvar canPlaceBlock = function (segment, start, length) {\n    // Check if block fits and doesn't violate existing constraints\n    if (start + length > segment.length)\n        return false;\n    if (start > 0 && segment[start - 1] === 2)\n        return false;\n    if (start + length < segment.length && segment[start + length] === 2)\n        return false;\n    for (var i = 0; i < length; i++) {\n        if (segment[start + i] === 1)\n            return false;\n    }\n    return true;\n};\nvar getMinSpaceNeeded = function (hints) {\n    return hints.reduce(function (sum, hint) { return sum + hint; }, 0) + Math.max(0, hints.length - 1);\n};\nvar canPlaceHints = function (hints, segment, startIndex) {\n    var cacheKey = getCacheKey(hints, segment, startIndex);\n    if (memoCache.has(cacheKey))\n        return memoCache.get(cacheKey);\n    // Base case: no more hints to place\n    if (hints.length === 0) {\n        // Check if remaining segment has any filled cells\n        var valid = !segment.slice(startIndex).some(function (cell) { return cell === 2; });\n        memoCache.set(cacheKey, valid);\n        return valid;\n    }\n    var currentHint = hints[0], remainingHints = hints.slice(1);\n    var maxStart = segment.length - getMinSpaceNeeded(hints);\n    for (var i = startIndex; i <= maxStart; i++) {\n        if (canPlaceBlock(segment, i, currentHint)) {\n            var nextStart = i + currentHint + 1;\n            if (canPlaceHints(remainingHints, segment, nextStart)) {\n                memoCache.set(cacheKey, true);\n                return true;\n            }\n        }\n        // Skip positions that must be filled\n        if (segment[i] === 2)\n            break;\n    }\n    memoCache.set(cacheKey, false);\n    return false;\n};\nvar checkMustBe = function (hints, segment, position, value) {\n    var testSegment = __spreadArray([], segment, true);\n    testSegment[position] = value;\n    return canPlaceHints(hints, testSegment, 0);\n};\nexport {};\n";
const blob = new Blob([workerScript], { type: 'application/javascript' });
const workerUrl = URL.createObjectURL(blob);
export const getWorkerUrl = () => workerUrl;
